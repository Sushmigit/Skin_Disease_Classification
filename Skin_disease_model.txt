
# =============================================
# ✅ SKIN DISEASE CLASSIFICATION - FIXED VERSION
# =============================================

import kagglehub
import os
import numpy as np
import PIL
from tensorflow.keras.utils import to_categorical
from google.colab import files

# -------------------------------
# STEP 1: DOWNLOAD DATASET
# -------------------------------
dataset_path = kagglehub.dataset_download("riyaelizashaju/skin-disease-classification-image-dataset")
print("Dataset path:", dataset_path)

IMG_SAVE_PATH = os.path.join(dataset_path, "Split_smol/train")
IMG_SAVE_PATH_TESTING = os.path.join(dataset_path, "Split_smol/val")

# -------------------------------
# STEP 2: CLASS MAPPING
# -------------------------------
Str_to_Int = {
    'Actinic keratosis': 0,
    'Atopic Dermatitis': 1,
    'Benign keratosis': 2,
    'Dermatofibroma': 3,
    'Melanocytic nevus': 4,
    'Melanoma': 5,
    'Squamous cell carcinoma': 6,
    'Tinea Ringworm Candidiasis': 7,
    'Vascular lesion': 8
}

NUM_CLASSES = len(Str_to_Int)
IMAGE_SIZE = (240, 240)

# -------------------------------
# STEP 3: LOAD DATASET FUNCTION
# -------------------------------
def load_dataset(image_dir):
    dataset = []
    labels = []
    for directory in os.listdir(image_dir):
        path = os.path.join(image_dir, directory)
        if os.path.isdir(path):
            for image in os.listdir(path):
                new_path = os.path.join(path, image)
                if os.path.isfile(new_path) and new_path.lower().endswith(('.png', '.jpg', '.jpeg')):
                    try:
                        img = PIL.Image.open(new_path).convert('RGB')
                        img = img.resize(IMAGE_SIZE)
                        img = np.asarray(img) / 255.0
                        dataset.append(img)
                        labels.append(Str_to_Int[directory])
                    except Exception as e:
                        print(f"Error loading {new_path}: {e}")
    return np.array(dataset), to_categorical(labels, NUM_CLASSES)

# Load data
X_train, y_train = load_dataset(IMG_SAVE_PATH)
X_test, y_test = load_dataset(IMG_SAVE_PATH_TESTING)

print(f"✅ Training Data Shape: {X_train.shape}, Labels: {y_train.shape}")
print(f"✅ Testing Data Shape: {X_test.shape}, Labels: {y_test.shape}")

# -------------------------------
# STEP 4: BUILD FIXED MODEL (Functional API)
# -------------------------------
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import Dense, Dropout, GlobalAveragePooling2D, Input
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam

def build_mobilenet():
    input_layer = Input(shape=(240, 240, 3))
    base_model = MobileNetV2(weights="imagenet", include_top=False, input_tensor=input_layer)
    base_model.trainable = False  # Freeze base model

    x = base_model.output
    x = GlobalAveragePooling2D()(x)
    x = Dense(128, activation='relu')(x)
    x = Dropout(0.5)(x)
    output_layer = Dense(NUM_CLASSES, activation='softmax')(x)

    model = Model(inputs=input_layer, outputs=output_layer)
    return model

model = build_mobilenet()
model.compile(optimizer=Adam(learning_rate=0.0001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

model.summary()

# -------------------------------
# STEP 5: TRAIN MODEL
# -------------------------------
history = model.fit(
    X_train, y_train,
    epochs=20,
    batch_size=32,
    validation_data=(X_test, y_test)
)

# -------------------------------
# STEP 6: EVALUATE MODEL
# -------------------------------
test_loss, test_acc = model.evaluate(X_test, y_test)
print(f"✅ Test Accuracy: {test_acc * 100:.2f}%")

# -------------------------------
# STEP 7: SAVE MODEL
# -------------------------------
model.save("skin_disease_classifier_mobilenetv2_fixed.h5")
print("✅ Model saved successfully as 'skin_disease_classifier_mobilenetv2_fixed.h5'")

# -------------------------------
# STEP 8: PREDICTION FUNCTION
# -------------------------------
def predict_skin_disease(image_path, model):
    img = PIL.Image.open(image_path).convert('RGB')
    img = img.resize((240, 240))
    img = np.asarray(img) / 255.0
    img = np.expand_dims(img, axis=0)
    prediction = model.predict(img)
    predicted_class = np.argmax(prediction)
    class_labels = list(Str_to_Int.keys())
    print(f"Predicted Disease: {class_labels[predicted_class]} with confidence {np.max(prediction) * 100:.2f}%")

# -------------------------------
# STEP 9: CONFUSION MATRIX
# -------------------------------
from sklearn.metrics import confusion_matrix, classification_report
import matplotlib.pyplot as plt
import seaborn as sns

y_pred = model.predict(X_test)
y_pred_classes = np.argmax(y_pred, axis=1)
y_true_classes = np.argmax(y_test, axis=1)

cm = confusion_matrix(y_true_classes, y_pred_classes)

plt.figure(figsize=(10,7))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues",
            xticklabels=Str_to_Int.keys(),
            yticklabels=Str_to_Int.keys())
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

# -------------------------------
# STEP 10: ACCURACY & LOSS PLOTS
# -------------------------------
plt.figure(figsize=(14, 5))

# Accuracy plot
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy', color='green')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy', color='blue')
plt.title('Model Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.grid(True)

# Loss plot
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss', color='red')
plt.plot(history.history['val_loss'], label='Validation Loss', color='orange')
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# -------------------------------
# STEP 11: DOWNLOAD MODEL
# -------------------------------
files.download("skin_disease_classifier_mobilenetv2_fixed.h5")

# -------------------------------
# STEP 12: CLASSIFICATION REPORT
# -------------------------------
report = classification_report(y_true_classes, y_pred_classes, target_names=Str_to_Int.keys())
print("Classification Report:\n")
print(report)